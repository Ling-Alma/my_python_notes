import os

import pandas as pd

# Assignment 1

# This assignment will start with basic python tasks that a big-data economist might face. Questions will ask
# for you to print things to show that you got the answer right. For full credit, make sure your print
# statements are descriptive enough that I know which answer it was a part of, e.g.:
# print("Question 1a:", answer)
# Finally, also use comments to explain steps you are doing.
# no need to go overboard but it is always important in coding to be as descriptive as possible.
# Most things in this can be solved using methods shown in lecture. However, some cases will
# require you to search the internet for answers. This is intended because efficiently searching
# documentation or Stackoverflow is a requirement of modern programing. Finally, you'll notice this is
# already a python file, but all the questions are commented out. Add your answers (uncommented) in the
# approporate spot. Note that you will need to save this file in a NEW DIRECTORY, otherwise it will
# be conflict with whatever I put into this class repository. Some of you have asked if there
# is an elegant way to do this in verison control, and yes there is. You could fork the class repo
# to be your own and then edit it there, but this is not a requirement.

# To submit this file, upload the finished file as assignment_04_<YOUR_NAME>.py
# No need to submit the files that get generated, e.g., the PNG files because
# these should  be generated by me when I'm running your code.


# Problem 1: Filesystems (30 pts)

# The python library named os is a built-in library for dealing with any file on your operating system.
# Often, research tasks involve LOTS of files and you need to iterate over them. To show you know how
# to do this, use the os.listdir function to answer:

# QUESTION 1a - 5 pts
# Print out a list of all the files in the class Data directory (which you have gotten from Google Drive)
# I don't care how many are actually there (in case you've added some yourself) but show me how.
# Reminder: Use a relative path so that when I run this script in the expected working directory, it is able to find
# the files on MY computer. This means your folders should be arranged like this (how I had said in lecture)

# - CLASS DIRECTORY
# -- Data
# -- Code
# --- python_for_big_data
# ---- assignment_4p.py

a = os.listdir('../../Data/')
print('QUESTION 1a', "The list of files (including sub-folders) in my data folder: ", a)

# Question 1b - 5 pts
# Using a for loop over that list, count how many times the character string "maize" occurs in the file NAMES
# (excluding the folders leading to the file)
count = 0
for x in a:
    if "maize" in x:
    count = count + 1
print('QUESTION 1b', "The number of files 'maize' in the name is", count)


# Question 1c - 10 pts
# Using os.path.splitext(), count how many files have the ".tif" extension
# Note, obviously you could count it visually, but do it programatically.
# Note that os.path.splitext() returns list 2 elements long and only 1 element of those is
# what you want.
tifs = 0
for x in a:
    root_ext = os.path.splitext(x)
    if root_ext[1] == ".tif":
        tifs = tifs + 1
print('QUESTION 1c', "The number of .tif files in my data folder is", tifs)



# Question 1d - 10 pts
# Using stackexchange (or wherever) to find the right functions, create a list
# of all the filesizes in the Data directory sorted largest to smallest. Note that to get the filesize, you need to point
# the funciton to the whole filepath (directory and filename). There is a handy os.path function that joins
# directories and filenames. If you want to impress me (no extra points assigned),
# Print out a sorted list of filename, filesize.

paths = [os.path.join('../../Data/', x) for x in os.listdir('../../Data/')]
sizes = [round(os.path.getsize(x)/1024) for x in paths]
tb = pd.DataFrame({'File path': a, 'File size (KB)': sizes}).sort_values('File size (KB)', ascending=False)
print('QUESTION 1d',tb) # The sizes matched numbers in my file explorer


## Question 2: 70 pts

# Question 2a - 10 pts
# Using Pandas, read in the Production_Crops_E_All_Data_(Normalized).csv file. Note that
# When unzipped this file is 253 MB. This is not HUGE data but it's pretty big and would not be able to be
# Fully opened in Excel. I guess this means we are finally, officially, entering the territory of "BIG DATA"
# Insofar as some tools will now fail. Also note that I've given you a CSV exactly as it is provided by
# the FAO and that this file was "encoded" in a strange way. You will need to give an
# encoding='latin' argument to tell your computer how to read the file. This is a common problem
# with using external data so I thought I'd have you work through the solution.
# Save the column headers to a list and print it out. Also print out the number of rows.

crops = pd.read_csv('../../Data/Production_Crops_E_All_Data_(Normalized).csv', encoding='latin1')
print('QUESTION 2a', 'The variables in the excel file are:', list(crops.columns))
print('QUESTION 2a', 'The number of rows is', crops.shape[0])


# Question 2b - 10 pts
# Pare down the dataframe to only have Production as the element. (Element is variable name in FAO
# lingo). In other words, reduce the size of the DF so that it only has Production statistics,
# rather than additional variables like Harvested Area.
# You can do this with the df.loc method

production = crops[crops['Element'].isin(['Production'])]
print('QUESTION 2b', 'After keeping only the production information, the number of rows is reduced to', production.shape[0])

# Question 2c - 10 pts
# Use pandas unique() function to get a list of all Area names used in this table and all the Item names used.
# print these both out.
countries = production['Area'].unique()
print('QUESTION 2c', 'The list of countries is', countries)
items = production['Item'].unique()
print('QUESTION 2c', 'The list of crops is', items)


# Question 2d - 10 pts
# Produce a line-graph of Production from 1961 to 2019 of Maize in Canada. To do this, you may want to first
# to use .loc again to pare down the dataframe to only have the required info. For plotting, use matplotlib.
# Hint: the import statement for matplotlib is
# import matplotlib.pyplot as plt
# don't forget to call plt.show() or otherwise it plots it but never actually displays it.

maize_CA = production.loc[(production['Area'] == "Canada") & (production['Item'] == "Maize"), ['Year', 'Value']]
import matplotlib.pyplot as plt
plt.plot(maize_CA['Year'], maize_CA['Value'])
plt.xlabel('Year')
plt.ylabel('Maize Production')
plt.show()

# Question 2e - 10 pts
# Notice that data are in vertical, stacked, etc. format. When dealing with multiple countries, it may be
# useful to put years into different column headers. This is referred to as unstacking
# the data. Modify one of your previous steps to create a dataframe that has each Area in a unique
# row and each year in a unique column. A useful command might be pd.pivot_table()
# Print out this new dataframe, but also save it to a file named "question_2e.csv" in the current
# working directory.

production_wide = pd.pivot_table(production, values='Value', index=['Area'], columns='Year', aggfunc=np.sum, fill_value=0)
production_wide.to_csv('question_2e.csv')


# Question 2f - 10 pts
# Create an unstacked dataframe similar to above except with ALL of the different crops (Items) included.
# If you saved previous steps' dataframes, you might already have the one you need to pivot on, otherwise recreate it.
# Print and save this to question_2f.csv

production_wide1 = pd.pivot_table(production, values='Value', index=['Area', 'Item'], columns='Year', fill_value=0)
production_wide1.to_csv('question_2f.csv')


# Question 2g - 10 pts
# Plot the total production tonnage of all crops for all countries over time. Save this figure as  question_2g.png
# Consider using plt.savefig(). Also note that if you call savefig after you called plt.show() on this
# plot, the saved file will be blank because .show() clears what you plotted.
plt.plot(production_wide.loc['World',])
plt.savefig('question_2g.png')

